# Диаграммы архитектуры BoomBet

## 1. Общая архитектура системы (High-Level)

```mermaid
graph TB
    subgraph "Client Layer"
        FE[React Frontend<br/>Port 3000]
    end

    subgraph "API Layer"
        GW[API Gateway<br/>Port 8080<br/>Spring Cloud Gateway]
    end

    subgraph "Service Layer"
        AUTH[Auth Service<br/>Port 8081<br/>Аутентификация]
        CORE[Core Service<br/>Port 8082<br/>Бизнес-логика]
        RT[Realtime Service<br/>Port 8083<br/>Генерация данных]
    end

    subgraph "Data Layer"
        DB[(PostgreSQL<br/>Port 5432)]
        KAFKA[Apache Kafka<br/>Port 9092]
        ZK[Zookeeper<br/>Port 2181]
    end

    FE -->|HTTP/REST| GW
    GW -->|HTTP| AUTH
    GW -->|HTTP| CORE
    GW -->|WebSocket| RT

    AUTH -->|JDBC| DB
    CORE -->|JDBC| DB

    RT -->|Producer| KAFKA
    CORE -->|Consumer| KAFKA
    KAFKA -->|Coordination| ZK

    style FE fill:#61dafb
    style GW fill:#6db33f
    style AUTH fill:#ffa500
    style CORE fill:#ff6b6b
    style RT fill:#4ecdc4
    style DB fill:#336791
    style KAFKA fill:#231f20
```

## 2. Детальная схема коммуникации

```mermaid
sequenceDiagram
    participant F as Frontend
    participant G as API Gateway
    participant A as Auth Service
    participant C as Core Service
    participant R as Realtime Service
    participant K as Kafka
    participant DB as PostgreSQL

    Note over F,DB: 1. Аутентификация
    F->>G: POST /api/auth/login
    G->>A: Forward request
    A->>DB: Проверка credentials
    DB-->>A: User data
    A->>A: Генерация JWT
    A-->>G: JWT + User data
    G-->>F: Response

    Note over F,DB: 2. Просмотр событий
    F->>G: GET /api/v1/events/live
    G->>G: Проверка открытого endpoint
    G->>C: Forward request
    C->>DB: SELECT events
    DB-->>C: Events data
    C-->>G: Events list
    G-->>F: Response

    Note over F,DB: 3. Размещение ставки
    F->>G: POST /api/v1/bets + JWT
    G->>G: Валидация JWT
    G->>C: Forward + X-Auth-Header
    C->>DB: BEGIN TRANSACTION
    C->>DB: INSERT bet
    C->>DB: UPDATE balance
    C->>DB: COMMIT
    DB-->>C: Success
    C-->>G: Bet created
    G-->>F: Response

    Note over R,DB: 4. Обновление odds (async)
    R->>R: Scheduler (15s)
    R->>R: Generate mock data
    R->>K: Publish event
    K-->>C: Consume event
    C->>DB: UPDATE odds
    DB-->>C: Success
```

## 3. Архитектура данных (Database Schema)

```mermaid
erDiagram
    USERS ||--o{ BETS : places
    USERS ||--o{ TRANSACTIONS : has
    BETS ||--|{ BET_ITEMS : contains
    BET_ITEMS }o--|| OUTCOMES : references
    OUTCOMES }o--|| MARKETS : belongs_to
    MARKETS }o--|| EVENTS : belongs_to
    EVENTS }o--|| SPORTS : has

    USERS {
        bigserial user_id PK
        varchar email UK
        varchar password
        decimal balance
        timestamp created_at
        varchar status
    }

    SPORTS {
        serial sport_id PK
        varchar name
    }

    EVENTS {
        bigserial event_id PK
        varchar external_id UK
        int sport_id FK
        varchar team_a
        varchar team_b
        timestamp start_time
        varchar status
        varchar result
    }

    MARKETS {
        bigserial market_id PK
        bigint event_id FK
        varchar name
    }

    OUTCOMES {
        bigserial outcome_id PK
        bigint market_id FK
        varchar name
        decimal current_odds
        boolean is_active
    }

    BETS {
        bigserial bet_id PK
        bigint user_id FK
        decimal stake_amount
        decimal total_odds
        decimal potential_payout
        varchar status
        timestamp created_at
    }

    BET_ITEMS {
        bigserial bet_item_id PK
        bigint bet_id FK
        bigint outcome_id FK
        decimal odds_at_bet_time
    }

    TRANSACTIONS {
        bigserial transaction_id PK
        bigint user_id FK
        decimal amount
        varchar type
        timestamp created_at
    }
```

## 4. Kafka Event Flow

```mermaid
graph LR
    subgraph "Realtime Service"
        S[Scheduler<br/>15 sec interval]
        G[Mock Data<br/>Generator]
        P[Kafka<br/>Producer]
    end

    subgraph "Kafka Cluster"
        T[Topic:<br/>events-updates<br/>Partitions: 1<br/>Replication: 1]
    end

    subgraph "Core Service"
        C[Kafka<br/>Consumer<br/>Group: core-service-group]
        L[Event Update<br/>Listener]
        ES[Event<br/>Service]
    end

    subgraph "Database"
        DB[(PostgreSQL)]
    end

    S -->|Trigger| G
    G -->|Create DTO| P
    P -->|Publish| T
    T -->|Poll| C
    C -->|Deserialize| L
    L -->|Process| ES
    ES -->|Upsert| DB

    style S fill:#4ecdc4
    style G fill:#4ecdc4
    style P fill:#4ecdc4
    style T fill:#231f20,color:#fff
    style C fill:#ff6b6b
    style L fill:#ff6b6b
    style ES fill:#ff6b6b
    style DB fill:#336791
```

## 5. API Gateway Routing

```mermaid
graph TD
    FE[Frontend<br/>localhost:3000]

    subgraph "API Gateway :8080"
        GW[Gateway<br/>Router]
        AF[Authentication<br/>Filter]
        RV[Router<br/>Validator]
        JWT[JWT<br/>Util]
    end

    AUTH[Auth Service<br/>:8081]
    CORE[Core Service<br/>:8082]
    RT[Realtime Service<br/>:8083]

    FE -->|HTTP Request| GW
    GW --> RV
    RV -->|Open Endpoint| AUTH
    RV -->|Open Endpoint| CORE
    RV -->|Secured Endpoint| AF
    AF -->|Validate| JWT
    JWT -->|Valid| CORE
    JWT -->|Invalid| FE

    GW -->|/api/auth/**| AUTH
    GW -->|/api/v1/**| CORE
    GW -->|/ws/updates/**| RT

    style GW fill:#6db33f
    style AF fill:#ffa500
    style RV fill:#ffa500
    style JWT fill:#ffa500
```

## 6. Deployment Architecture (Docker Compose)

```mermaid
graph TB
    subgraph "Docker Network: boombet-network"
        subgraph "Infrastructure"
            ZK[Zookeeper<br/>:2181]
            K[Kafka<br/>:9092, :29092]
            DB[(PostgreSQL<br/>:5432)]
        end

        subgraph "Application Services"
            GW[API Gateway<br/>:8080]
            AUTH[Auth Service<br/>:8081]
            CORE[Core Service<br/>:8082]
            RT[Realtime Service<br/>:8083]
        end
    end

    HOST[Host Machine<br/>localhost]

    K -.->|depends_on| ZK
    AUTH -.->|depends_on| DB
    CORE -.->|depends_on| DB
    CORE -.->|depends_on| K
    RT -.->|depends_on| K
    GW -.->|depends_on| AUTH
    GW -.->|depends_on| CORE
    GW -.->|depends_on| RT

    HOST -->|Port Mapping| GW
    HOST -->|Port Mapping| K
    HOST -->|Port Mapping| DB

    style ZK fill:#a8dadc
    style K fill:#231f20,color:#fff
    style DB fill:#336791
    style GW fill:#6db33f
    style AUTH fill:#ffa500
    style CORE fill:#ff6b6b
    style RT fill:#4ecdc4
```

## 7. Security Flow (JWT Authentication)

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant G as Gateway
    participant A as Auth Service
    participant C as Core Service
    participant DB as Database

    Note over U,DB: Registration
    U->>F: Ввод email/password
    F->>G: POST /api/auth/register
    G->>A: Forward
    A->>A: BCrypt hash password
    A->>DB: INSERT user
    DB-->>A: user_id
    A-->>G: Success
    G-->>F: User created

    Note over U,DB: Login
    U->>F: Ввод email/password
    F->>G: POST /api/auth/login
    G->>A: Forward
    A->>DB: SELECT user
    DB-->>A: User + hashed password
    A->>A: BCrypt verify
    A->>A: Generate JWT<br/>(secret key + expiration)
    A-->>G: JWT token + user data
    G-->>F: Response
    F->>F: Store token in localStorage

    Note over U,DB: Protected Request
    F->>G: GET /api/v1/bets<br/>Authorization: Bearer {JWT}
    G->>G: Extract JWT from header
    G->>G: Validate signature
    G->>G: Check expiration
    alt JWT Valid
        G->>G: Add X-Authenticated-User-Email
        G->>C: Forward with header
        C->>DB: Query user's bets
        DB-->>C: Bets data
        C-->>G: Response
        G-->>F: Response
    else JWT Invalid
        G-->>F: 401 Unauthorized
        F->>F: Clear localStorage
        F->>F: Redirect to /login
    end
```

## 8. Microservices Communication Patterns

```mermaid
graph TB
    subgraph "Synchronous Communication"
        F1[Frontend] -->|REST/HTTP| G1[API Gateway]
        G1 -->|REST/HTTP| A1[Auth Service]
        G1 -->|REST/HTTP| C1[Core Service]
    end

    subgraph "Asynchronous Communication"
        R2[Realtime Service] -->|Kafka Producer| K2[Kafka Broker]
        K2 -->|Kafka Consumer| C2[Core Service]
    end

    subgraph "Database Access"
        A3[Auth Service] -->|JDBC/JPA| DB1[(PostgreSQL)]
        C3[Core Service] -->|JDBC/JPA| DB2[(PostgreSQL)]
    end

    style F1 fill:#61dafb
    style G1 fill:#6db33f
    style A1 fill:#ffa500
    style C1 fill:#ff6b6b
    style R2 fill:#4ecdc4
    style K2 fill:#231f20,color:#fff
    style C2 fill:#ff6b6b
    style A3 fill:#ffa500
    style C3 fill:#ff6b6b
    style DB1 fill:#336791
    style DB2 fill:#336791
```

## Как использовать эти диаграммы

1. **Для презентации**: Скопируйте код Mermaid в онлайн редактор https://mermaid.live/
2. **Для документации**: GitHub и многие IDE (VS Code с расширением) поддерживают Mermaid
3. **Для экспорта**: Из mermaid.live можно экспортировать в PNG/SVG/PDF

## Ключевые точки для защиты

При объяснении архитектуры на защите акцентируй внимание на:

1. **Почему микросервисы, а не монолит?**

   - Независимое масштабирование
   - Изоляция сбоев
   - Гибкость технологий
   - Параллельная разработка

2. **Почему API Gateway?**

   - Единая точка входа
   - Централизованная аутентификация
   - Упрощение клиента
   - Возможность rate limiting

3. **Почему Kafka?**

   - Асинхронность
   - Надежность доставки
   - Масштабируемость
   - Decoupling сервисов

4. **Почему JWT?**

   - Stateless аутентификация
   - Не нужна сессия на сервере
   - Легко масштабируется
   - Содержит claims (user info)

5. **Почему PostgreSQL?**

   - ACID транзакции (критично для ставок)
   - Сложные JOIN'ы
   - Надежность
   - Зрелость технологии

6. **Компромиссы архитектуры:**
   - Сложность vs Гибкость
   - Network latency vs Изоляция
   - Eventual consistency vs Strong consistency
   - Operational overhead vs Масштабируемость
