# BoomBet - Архитектура микросервисной системы для онлайн-ставок

## Обзор системы

BoomBet - это платформа для онлайн-ставок на спортивные события, построенная на микросервисной архитектуре с использованием Spring Boot, Apache Kafka и PostgreSQL.

## Архитектурная схема

```
                                    ┌─────────────────┐
                                    │   Frontend      │
                                    │   (React +      │
                                    │   TypeScript)   │
                                    │  localhost:3000 │
                                    └────────┬────────┘
                                             │ HTTP/REST
                                             │ WebSocket
                                    ┌────────▼────────┐
                                    │  API Gateway    │
                                    │   (Port 8080)   │
                                    │  Spring Cloud   │
                                    │    Gateway      │
                                    └────────┬────────┘
                                             │
                    ┌────────────────────────┼────────────────────────┐
                    │                        │                        │
          HTTP/REST │              HTTP/REST │              WebSocket │
                    │                        │                        │
         ┌──────────▼──────────┐  ┌─────────▼──────────┐  ┌──────────▼──────────┐
         │  Auth Service       │  │  Core Service      │  │ Realtime Service    │
         │   (Port 8081)       │  │   (Port 8082)      │  │   (Port 8083)       │
         │                     │  │                    │  │                     │
         │ - Регистрация       │  │ - События          │  │ - Генерация данных  │
         │ - Аутентификация    │  │ - Ставки           │  │ - Обновления odds   │
         │ - JWT токены        │  │ - Профиль          │  │ - Scheduler         │
         │ - Spring Security   │  │ - Транзакции       │  │                     │
         └──────────┬──────────┘  └─────────┬──────────┘  └──────────┬──────────┘
                    │                       │                         │
                    │ JDBC                  │ JDBC                    │ Kafka Producer
                    │                       │                         │
         ┌──────────▼───────────────────────▼─────────┐               │
         │          PostgreSQL Database               │               │
         │              (Port 5432)                   │               │
         │                                            │               │
         │  ┌──────────┐  ┌─────────┐  ┌──────────┐ │               │
         │  │  users   │  │ events  │  │  bets    │ │               │
         │  │  table   │  │ markets │  │  table   │ │               │
         │  └──────────┘  │ outcomes│  └──────────┘ │               │
         │                └─────────┘                │               │
         └────────────────────────────────────────────┘               │
                                                                      │
                              ┌───────────────────────────────────────┘
                              │
                    ┌─────────▼──────────┐
                    │   Apache Kafka     │
                    │    (Port 9092)     │
                    │                    │
                    │  Topic:            │
                    │  events-updates    │
                    └─────────┬──────────┘
                              │ Kafka Consumer
                              │
                    ┌─────────▼──────────┐
                    │   Core Service     │
                    │  (Kafka Listener)  │
                    │                    │
                    │ Обработка событий  │
                    │ Обновление БД      │
                    └────────────────────┘
```

## Компоненты системы

### 1. API Gateway (Spring Cloud Gateway)

**Порт:** 8080  
**Технологии:** Spring Cloud Gateway, Spring WebFlux

**Назначение:**

- Единая точка входа для всех клиентских запросов
- Маршрутизация запросов к соответствующим микросервисам
- Проверка JWT токенов для защищенных эндпоинтов
- CORS конфигурация для frontend
- Load balancing (при масштабировании)

**Маршруты:**

```
/api/auth/**        → auth-service:8081
/api/v1/**          → core-service:8082
/ws/updates/**      → realtime-service:8083
```

**Ключевые компоненты:**

- `GatewayConfig.java` - конфигурация маршрутов
- `AuthenticationFilter.java` - фильтр для валидации JWT
- `RouterValidator.java` - определение открытых/защищенных эндпоинтов
- `JwtUtil.java` - утилита для работы с JWT токенами

**Почему нужен:**

- Скрывает внутреннюю структуру микросервисов от клиента
- Централизованная аутентификация и авторизация
- Упрощает масштабирование и добавление новых сервисов
- Снижает количество прямых зависимостей между клиентом и сервисами

---

### 2. Auth Service

**Порт:** 8081  
**Технологии:** Spring Boot, Spring Security, JWT, PostgreSQL

**Назначение:**

- Управление пользователями и аутентификацией
- Генерация и валидация JWT токенов
- Регистрация новых пользователей
- Хранение учетных данных

**API Endpoints:**

```
POST /api/auth/register - Регистрация пользователя
POST /api/auth/login    - Вход в систему (возвращает JWT + данные пользователя)
```

**База данных:**

```sql
users (
    user_id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    balance DECIMAL(10,2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    status VARCHAR(50) DEFAULT 'ACTIVE'
)
```

**Ключевые компоненты:**

- `SecurityConfig.java` - конфигурация Spring Security
- `JwtService.java` - генерация и валидация JWT
- `AuthController.java` - REST endpoints
- `UserRepository.java` - работа с БД

**Почему отдельный сервис:**

- Безопасность: изоляция критичных данных (пароли, токены)
- Возможность независимого масштабирования при высокой нагрузке на аутентификацию
- Переиспользование в других проектах
- Четкое разделение ответственности (Single Responsibility Principle)

---

### 3. Core Service

**Порт:** 8082  
**Технологии:** Spring Boot, PostgreSQL, Kafka Consumer, JPA/Hibernate

**Назначение:**

- Основная бизнес-логика системы ставок
- Управление спортивными событиями и маркетами
- Обработка ставок пользователей
- Управление балансом и транзакциями
- Потребление событий из Kafka

**API Endpoints:**

```
# События
GET  /api/v1/events/upcoming           - Предстоящие события
GET  /api/v1/events/live               - Live события
GET  /api/v1/events/status/{status}    - События по статусу
GET  /api/v1/events/sport/{sportId}    - События по виду спорта
GET  /api/v1/events/{id}/markets       - Маркеты для события
POST /api/v1/events/filter             - Фильтрация событий

# Ставки
POST /api/v1/bets                      - Создать ставку
GET  /api/v1/bets                      - История ставок пользователя

# Профиль пользователя
GET  /api/v1/users/me                  - Текущий пользователь
GET  /api/v1/users/profile             - Профиль пользователя
GET  /api/v1/users/balance             - Баланс
POST /api/v1/users/deposit             - Пополнение
POST /api/v1/users/withdraw            - Вывод средств
```

**База данных:**

```sql
sports (sport_id, name)
events (event_id, external_id, sport_id, team_a, team_b, start_time, status, result)
markets (market_id, event_id, name)
outcomes (outcome_id, market_id, name, current_odds, is_active)
bets (bet_id, user_id, stake_amount, total_odds, potential_payout, status, created_at)
bet_items (bet_item_id, bet_id, outcome_id, odds_at_bet_time)
transactions (transaction_id, user_id, amount, type, created_at)
```

**Kafka Integration:**

- Consumer Group: `core-service-group`
- Topic: `events-updates`
- Listener: `EventUpdateListener.java`
- Обрабатывает обновления событий и коэффициентов в реальном времени

**Ключевые компоненты:**

- `EventService.java` - логика работы с событиями
- `BetService.java` - логика размещения ставок
- `UserProfileService.java` - управление профилем и балансом
- `EventUpdateListener.java` - Kafka listener

**Почему отдельный сервис:**

- Самый нагруженный сервис - требует независимого масштабирования
- Содержит критичную бизнес-логику
- Может работать с большим объемом транзакций
- Независимое развертывание и обновление

---

### 4. Realtime Service

**Порт:** 8083  
**Технологии:** Spring Boot, Kafka Producer, Spring Scheduler, WebSocket (планируется)

**Назначение:**

- Генерация mock данных для тестирования
- Имитация получения данных от внешних API (футбольные матчи)
- Публикация обновлений в Kafka
- Обновление коэффициентов в реальном времени

**Kafka Integration:**

- Producer
- Topic: `events-updates`
- Scheduler: каждые 15 секунд генерирует новое событие

**Генерируемые данные:**

```json
{
	"externalId": "uuid",
	"status": "live|upcoming",
	"homeTeam": "Team A",
	"awayTeam": "Team B",
	"homeScore": "2",
	"awayScore": "1",
	"markets": [
		{
			"name": "Match Winner",
			"outcomes": [
				{ "name": "Team A", "price": 2.5 },
				{ "name": "Team B", "price": 3.2 },
				{ "name": "Draw", "price": 3.4 }
			]
		},
		{
			"name": "Total Goals",
			"outcomes": [
				{ "name": "Over 2.5", "price": 1.85 },
				{ "name": "Under 2.5", "price": 2.1 }
			]
		}
	]
}
```

**Ключевые компоненты:**

- `DataFetchScheduler.java` - генерация mock данных
- `MatchUpdateDTO.java` - структура данных события

**Почему отдельный сервис:**

- Изоляция внешних интеграций (в будущем - реальные API букмекеров)
- Независимое масштабирование при подключении множества источников данных
- Отсутствие зависимости от БД (stateless)
- Легко заменить на реальную интеграцию без изменения других сервисов

---

### 5. Apache Kafka

**Порты:** 9092 (external), 29092 (internal)  
**Технологии:** Apache Kafka, Zookeeper

**Назначение:**

- Асинхронная передача сообщений между сервисами
- Event-driven архитектура
- Decoupling между producers и consumers
- Гарантия доставки сообщений

**Topics:**

- `events-updates` - обновления спортивных событий и коэффициентов

**Схема потока данных:**

```
Realtime Service (Producer)
    ↓ публикует в Kafka
Kafka Topic: events-updates
    ↓ читает из Kafka
Core Service (Consumer)
    ↓ обновляет
PostgreSQL Database
```

**Почему Kafka:**

- **Асинхронность**: Realtime Service не ждет обработки Core Service
- **Масштабируемость**: Можно добавить несколько consumers
- **Надежность**: Гарантия доставки, персистентность сообщений
- **Replay**: Возможность переобработать сообщения
- **Decoupling**: Сервисы не знают друг о друге напрямую

**Альтернативы и почему выбрали Kafka:**

- RabbitMQ - проще, но меньше throughput
- Redis Pub/Sub - быстрее, но нет персистентности
- REST API - синхронный, тесная связанность
- **Kafka** - баланс между производительностью, надежностью и масштабируемостью

---

### 6. PostgreSQL Database

**Порт:** 5432  
**Технологии:** PostgreSQL 15

**Назначение:**

- Хранение всех данных системы
- ACID транзакции для ставок
- Реляционная модель данных

**Схема базы данных:**

```
┌──────────────┐
│    users     │
│──────────────│
│ user_id (PK) │
│ email        │
│ password     │
│ balance      │
│ created_at   │
│ status       │
└──────┬───────┘
       │
       │ 1:N
       │
┌──────▼───────┐      ┌──────────────┐
│    bets      │──┐   │ transactions │
│──────────────│  │   │──────────────│
│ bet_id (PK)  │  │   │ trans_id(PK) │
│ user_id (FK) │◄─┼───│ user_id (FK) │
│ stake_amount │  │   │ amount       │
│ total_odds   │  │   │ type         │
│ status       │  │   │ created_at   │
└──────┬───────┘  │   └──────────────┘
       │          │
       │ 1:N      │
       │          │
┌──────▼───────┐  │
│  bet_items   │  │
│──────────────│  │
│ item_id (PK) │  │
│ bet_id (FK)  │──┘
│ outcome_id   │◄───┐
│ odds_at_bet  │    │
└──────────────┘    │
                    │
┌──────────────┐    │
│   sports     │    │
│──────────────│    │
│ sport_id(PK) │    │
│ name         │    │
└──────┬───────┘    │
       │            │
       │ 1:N        │
       │            │
┌──────▼───────┐    │
│   events     │    │
│──────────────│    │
│ event_id(PK) │    │
│ sport_id(FK) │    │
│ external_id  │    │
│ team_a       │    │
│ team_b       │    │
│ start_time   │    │
│ status       │    │
│ result       │    │
└──────┬───────┘    │
       │            │
       │ 1:N        │
       │            │
┌──────▼───────┐    │
│   markets    │    │
│──────────────│    │
│ market_id(PK)│    │
│ event_id(FK) │    │
│ name         │    │
└──────┬───────┘    │
       │            │
       │ 1:N        │
       │            │
┌──────▼───────┐    │
│   outcomes   │    │
│──────────────│    │
│ outcome_id   │────┘
│ market_id(FK)│
│ name         │
│ current_odds │
│ is_active    │
└──────────────┘
```

**Почему PostgreSQL:**

- ACID транзакции критичны для финансовых операций (ставки, баланс)
- Сложные JOIN'ы для выборки связанных данных
- Хорошая производительность для OLTP
- JSON поддержка для гибких структур
- Надежность и зрелость

---

## Протоколы и технологии коммуникации

### 1. HTTP/REST

**Используется между:**

- Frontend ↔ API Gateway
- API Gateway ↔ Auth Service
- API Gateway ↔ Core Service

**Особенности:**

- Синхронная коммуникация
- Stateless
- JSON формат данных
- RESTful принципы

### 2. WebSocket (планируется)

**Используется между:**

- Frontend ↔ API Gateway ↔ Realtime Service

**Особенности:**

- Двунаправленная связь
- Real-time обновления коэффициентов
- Низкая задержка

### 3. Kafka (Event Streaming)

**Используется между:**

- Realtime Service → Kafka → Core Service

**Особенности:**

- Асинхронная коммуникация
- Pub/Sub модель
- Гарантия доставки
- Масштабируемость

### 4. JDBC

**Используется между:**

- Auth Service → PostgreSQL
- Core Service → PostgreSQL

**Особенности:**

- Синхронная коммуникация
- Транзакционность
- Connection pooling (HikariCP)

---

## Паттерны и принципы архитектуры

### 1. API Gateway Pattern

**Применение:** Единая точка входа через API Gateway

**Преимущества:**

- Упрощение клиентской логики
- Централизованная аутентификация
- Агрегация запросов
- Версионирование API

### 2. Database per Service

**Применение:**

- Auth Service имеет свою схему (users)
- Core Service имеет свою схему (events, bets, и т.д.)

**Преимущества:**

- Изоляция данных
- Независимое масштабирование БД
- Гибкость в выборе типа БД для каждого сервиса

**Примечание:** В текущей реализации используется одна физическая БД, но разные схемы/таблицы для разных сервисов.

### 3. Event-Driven Architecture

**Применение:** Kafka для асинхронных обновлений

**Преимущества:**

- Слабая связанность (loose coupling)
- Масштабируемость
- Надежность
- Асинхронная обработка

### 4. Circuit Breaker (планируется)

**Применение:** Защита от каскадных сбоев

**Инструменты:** Resilience4j, Spring Cloud Circuit Breaker

### 5. Service Discovery (не реализовано)

**Возможные решения:** Eureka, Consul

**Текущее состояние:** Хардкод адресов в конфигурации

---

## Безопасность

### 1. Аутентификация

- **JWT токены** (JSON Web Tokens)
- Выдаются Auth Service при успешном логине
- Срок действия токена конфигурируется
- Передаются в заголовке `Authorization: Bearer <token>`

### 2. Авторизация

- **Gateway-level**: Проверка токена в API Gateway
- **Service-level**: Проверка прав доступа в Core Service
- **Открытые эндпоинты**: регистрация, логин, просмотр событий
- **Защищенные эндпоинты**: размещение ставок, профиль, баланс

### 3. CORS

- Настроен в API Gateway
- Разрешен доступ с `localhost:3000` (frontend)
- Разрешенные методы: GET, POST, PUT, DELETE, OPTIONS
- Разрешенные заголовки: Authorization, Content-Type

### 4. Хеширование паролей

- **BCrypt** для хеширования паролей пользователей
- Никогда не храним пароли в открытом виде

---

## Масштабируемость и производительность

### 1. Горизонтальное масштабирование

**Возможности:**

- Запуск нескольких инстансов каждого сервиса
- API Gateway балансирует нагрузку
- Kafka Consumer Groups распределяют сообщения

### 2. Кеширование (планируется)

- Redis для кеширования частых запросов
- Кеш коэффициентов
- Кеш активных событий

### 3. Database Optimization

- Индексы на часто используемых полях (email, external_id, status)
- Connection pooling (HikariCP)
- Транзакционная изоляция

### 4. Kafka Partitioning

- Распределение нагрузки по партициям
- Параллельная обработка сообщений

---

## Мониторинг и наблюдаемость (планируется)

### 1. Логирование

- **SLF4J + Logback**
- Структурированные логи (JSON)
- Уровни: INFO, DEBUG, ERROR

### 2. Метрики

- **Spring Boot Actuator**
- **Prometheus** для сбора метрик
- **Grafana** для визуализации

### 3. Трейсинг

- **Spring Cloud Sleuth**
- **Zipkin** для distributed tracing

### 4. Health Checks

- Actuator endpoints: `/actuator/health`
- Проверка доступности БД, Kafka

---

## Развертывание

### 1. Контейнеризация

- **Docker** для каждого сервиса
- **Docker Compose** для локальной разработки
- Единая сеть: `boombet-network`

### 2. CI/CD (планируется)

- GitHub Actions для автоматических тестов
- Автоматический build Docker образов
- Деплой в Kubernetes

### 3. Оркестрация (планируется)

- **Kubernetes** для production
- **Helm Charts** для управления конфигурациями
- **Ingress** для маршрутизации трафика

---

## Потоки данных

### 1. Регистрация и вход

```
Frontend
    ↓ POST /api/auth/register
API Gateway
    ↓ forward to auth-service:8081
Auth Service
    ↓ хеширование пароля (BCrypt)
    ↓ сохранение в БД
PostgreSQL (users table)
    ← возврат user_id
Auth Service
    ↓ генерация JWT
    ↓ возврат { token, user data }
API Gateway
    ← forward response
Frontend
    ← сохранение в localStorage
```

### 2. Просмотр событий

```
Frontend
    ↓ GET /api/v1/events/live
API Gateway
    ↓ проверка открытого эндпоинта
    ↓ forward to core-service:8082
Core Service
    ↓ SELECT from events WHERE status='live'
PostgreSQL
    ← возврат списка событий
Core Service
    ← формирование EventResponse DTO
API Gateway
    ← forward response
Frontend
    ← отображение событий
```

### 3. Размещение ставки

```
Frontend
    ↓ POST /api/v1/bets + JWT token
API Gateway
    ↓ валидация JWT
    ↓ добавление X-Authenticated-User-Email header
    ↓ forward to core-service:8082
Core Service
    ↓ проверка баланса
    ↓ BEGIN TRANSACTION
    ↓ создание ставки (bets table)
    ↓ создание bet_items
    ↓ списание средств (users.balance)
    ↓ создание транзакции (transactions)
    ↓ COMMIT
PostgreSQL
    ← возврат bet_id
Core Service
    ← формирование ответа
API Gateway
    ← forward response
Frontend
    ← отображение успеха
```

### 4. Обновление коэффициентов (Real-time)

```
Realtime Service (Scheduler)
    ↓ каждые 15 секунд
    ↓ генерация MatchUpdateDTO
    ↓ публикация в Kafka
Kafka (events-updates topic)
    ↓ персистентность сообщения
    ↓ уведомление consumers
Core Service (Kafka Listener)
    ↓ получение сообщения
    ↓ createOrUpdateEvent()
    ↓ upsert event, markets, outcomes
    ↓ обновление current_odds
PostgreSQL
    ← подтверждение сохранения
Core Service
    ↓ commit Kafka offset
```

---

## Преимущества архитектуры

### 1. Масштабируемость

- Независимое масштабирование каждого сервиса
- Горизонтальное масштабирование через Kubernetes
- Kafka для обработки высоких нагрузок

### 2. Отказоустойчивость

- Изоляция сбоев (failure isolation)
- Сбой одного сервиса не влияет на другие
- Kafka гарантирует доставку сообщений

### 3. Гибкость разработки

- Разные команды могут работать над разными сервисами
- Независимые циклы релизов
- Выбор технологий под задачу каждого сервиса

### 4. Простота тестирования

- Unit тесты для каждого сервиса
- Integration тесты через Docker Compose
- Contract testing для API

### 5. Четкое разделение ответственности

- Каждый сервис решает одну задачу
- Легко понять и поддерживать
- Следование SOLID принципам

---

## Недостатки и компромиссы

### 1. Сложность

- Больше движущихся частей
- Сложнее debugging distributed systems
- Необходимость distributed tracing

### 2. Сетевые задержки

- Межсервисная коммуникация по сети
- Latency выше чем у монолита
- Требуется тщательная оптимизация

### 3. Консистентность данных

- Eventual consistency при использовании Kafka
- Сложнее поддерживать транзакции через несколько сервисов
- Требуется Saga pattern для distributed transactions

### 4. Operational overhead

- Больше контейнеров для мониторинга
- Сложнее настройка инфраструктуры
- Требуется DevOps expertise

---

## Возможные улучшения

### 1. Service Mesh

- **Istio** или **Linkerd**
- Управление трафиком между сервисами
- Mutual TLS
- Observability out of the box

### 2. Event Sourcing

- Хранение всех изменений как события
- Возможность replay и audit trail
- CQRS pattern

### 3. GraphQL Gateway

- Замена REST на GraphQL
- Гибкие запросы от клиента
- Уменьшение overfetching

### 4. Redis Cache

- Кеширование активных событий
- Кеширование коэффициентов
- Снижение нагрузки на БД

### 5. CDN для статики

- CloudFlare, AWS CloudFront
- Быстрая доставка frontend
- DDoS защита

---

## Заключение

Архитектура BoomBet спроектирована для поддержки онлайн-ставок с real-time обновлениями коэффициентов, высокой доступностью и возможностью горизонтального масштабирования.

Ключевые решения:

- **Микросервисная архитектура** для гибкости и масштабируемости
- **API Gateway** для централизованного управления трафиком
- **Kafka** для асинхронных обновлений в реальном времени
- **JWT** для безопасной аутентификации
- **PostgreSQL** для надежного хранения транзакций
- **Docker** для консистентного развертывания

Система готова к дальнейшему развитию и может быть развернута в production с минимальными доработками (добавление мониторинга, service discovery, улучшение безопасности).
