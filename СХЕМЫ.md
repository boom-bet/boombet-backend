# Схемы архитектуры BoomBet

## 1. Общая схема микросервисов (High-Level)

```mermaid
graph TB
    subgraph "Client Layer"
        FE[React Frontend<br/>:3000]
    end

    subgraph "API Gateway Layer"
        GW[API Gateway<br/>Spring Cloud Gateway<br/>:8080<br/><br/>- JWT Validation<br/>- Routing<br/>- Security]
    end

    subgraph "Microservices Layer"
        AUTH[Auth Service<br/>:8081<br/><br/>- Registration<br/>- Login<br/>- JWT Generation]
        CORE[Core Service<br/>:8082<br/><br/>- Events Management<br/>- Bet Placement<br/>- Bet Settlement<br/>- Balance Management]
        RT[Realtime Service<br/>:8083<br/><br/>- Mock Data Generator<br/>- External API Simulator]
    end

    subgraph "Data Layer"
        DB[(PostgreSQL<br/>:5432<br/><br/>- users<br/>- events<br/>- markets<br/>- outcomes<br/>- bets<br/>- transactions)]
        KAFKA[Apache Kafka<br/>:9092<br/><br/>Topics:<br/>- events-updates<br/>- notifications]
    end

    FE -->|HTTP/REST<br/>JWT Token| GW
    GW -->|/api/auth/**| AUTH
    GW -->|/api/v1/**| CORE
    GW -->|/api/v1/**| RT

    AUTH -->|JDBC| DB
    CORE -->|JDBC| DB
    RT -->|Kafka Producer| KAFKA
    KAFKA -->|Kafka Consumer| CORE

    style FE fill:#61dafb
    style GW fill:#6db33f
    style AUTH fill:#ff9900
    style CORE fill:#ff6600
    style RT fill:#9933ff
    style DB fill:#336791
    style KAFKA fill:#231f20
```

## 2. Детальная схема коммуникации с протоколами

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Gateway as API Gateway<br/>:8080
    participant Auth as Auth Service<br/>:8081
    participant Core as Core Service<br/>:8082
    participant RT as Realtime Service<br/>:8083
    participant Kafka as Apache Kafka
    participant DB as PostgreSQL

    Note over User,DB: 1. User Registration & Login
    User->>Frontend: Enter credentials
    Frontend->>Gateway: POST /api/auth/register
    Gateway->>Auth: Forward request
    Auth->>DB: INSERT INTO users
    DB-->>Auth: Success
    Auth-->>Gateway: User created
    Gateway-->>Frontend: 201 Created

    Frontend->>Gateway: POST /api/auth/login
    Gateway->>Auth: Forward credentials
    Auth->>DB: SELECT FROM users
    DB-->>Auth: User found
    Auth-->>Gateway: JWT Token
    Gateway-->>Frontend: {token, email}
    Frontend->>Frontend: Store JWT in localStorage

    Note over User,DB: 2. View Live Events
    User->>Frontend: Navigate to /live
    Frontend->>Gateway: GET /api/v1/events/live<br/>Authorization: Bearer JWT
    Gateway->>Gateway: Validate JWT
    Gateway->>Core: Forward with<br/>X-Authenticated-User-Email
    Core->>DB: SELECT * FROM events<br/>WHERE status='live'
    DB-->>Core: List of events
    Core-->>Gateway: Events JSON
    Gateway-->>Frontend: Events JSON
    Frontend->>User: Display events

    Note over User,DB: 3. Place Bet
    User->>Frontend: Select outcome, enter stake
    Frontend->>Gateway: POST /api/v1/bets<br/>{selections, stake}<br/>Authorization: Bearer JWT
    Gateway->>Core: Forward request
    Core->>DB: BEGIN TRANSACTION
    Core->>DB: UPDATE users SET balance
    Core->>DB: INSERT INTO bets
    Core->>DB: INSERT INTO betselections
    Core->>DB: INSERT INTO transactions
    Core->>DB: COMMIT
    DB-->>Core: Success
    Core->>Kafka: Publish to 'notifications'
    Core-->>Gateway: Bet created
    Gateway-->>Frontend: {betId, status: "pending"}
    Frontend->>User: Show bet confirmation

    Note over User,DB: 4. Realtime Updates
    RT->>RT: DataFetchScheduler (every 2 min)
    RT->>RT: Generate mock event
    RT->>Kafka: Publish to 'events-updates'<br/>{teams, odds, score}
    Kafka->>Core: EventUpdateListener
    Core->>DB: UPDATE events, markets, outcomes
    DB-->>Core: Success

    Note over User,DB: 5. Event Completion & Settlement
    User->>Frontend: Admin: Finish Event
    Frontend->>Gateway: POST /api/v1/events/{id}/finish<br/>{result: "2:1"}
    Gateway->>Core: Forward request
    Core->>DB: UPDATE events<br/>SET status='finished', result='2:1'

    Core->>Core: BetSettlementScheduler (every 30s)
    Core->>DB: SELECT * FROM events<br/>WHERE status='finished'
    DB-->>Core: Finished events
    Core->>DB: SELECT bets WHERE status='pending'
    DB-->>Core: Pending bets
    Core->>Core: Calculate winners
    Core->>DB: BEGIN TRANSACTION
    Core->>DB: UPDATE bets SET status='WON'
    Core->>DB: UPDATE users SET balance
    Core->>DB: INSERT INTO transactions<br/>type='WIN'
    Core->>DB: UPDATE events SET status='settled'
    Core->>DB: COMMIT
    Core->>Kafka: Publish to 'notifications'

    Note over User,DB: 6. View Bet History
    User->>Frontend: Navigate to /bets
    Frontend->>Gateway: GET /api/v1/bets/history
    Gateway->>Core: Forward with user email
    Core->>DB: SELECT bets WHERE user_id
    DB-->>Core: User's bets
    Core-->>Gateway: Bet history JSON
    Gateway-->>Frontend: Bet history JSON
    Frontend->>User: Display bets with status
```

## 3. Схема базы данных

```mermaid
erDiagram
    USERS ||--o{ BETS : places
    USERS ||--o{ TRANSACTIONS : has
    SPORTS ||--o{ EVENTS : categorizes
    EVENTS ||--o{ MARKETS : has
    MARKETS ||--o{ OUTCOMES : contains
    BETS ||--o{ BETSELECTIONS : includes
    OUTCOMES ||--o{ BETSELECTIONS : references

    USERS {
        bigint user_id PK
        varchar email UK
        varchar password_hash
        decimal balance
        varchar status
        timestamp created_at
    }

    SPORTS {
        bigint sport_id PK
        varchar name
        varchar category
    }

    EVENTS {
        bigint event_id PK
        bigint sport_id FK
        varchar team_a
        varchar team_b
        varchar status
        timestamp start_time
        varchar result
        varchar external_id UK
    }

    MARKETS {
        bigint market_id PK
        bigint event_id FK
        varchar name
        varchar type
        boolean is_active
    }

    OUTCOMES {
        bigint outcome_id PK
        bigint market_id FK
        varchar name
        decimal current_odds
        boolean is_active
    }

    BETS {
        bigint bet_id PK
        bigint user_id FK
        decimal stake_amount
        decimal total_odds
        decimal potential_payout
        varchar status
        timestamp created_at
    }

    BETSELECTIONS {
        bigint selection_id PK
        bigint bet_id FK
        bigint outcome_id FK
        decimal odds_at_placement
    }

    TRANSACTIONS {
        bigint transaction_id PK
        bigint user_id FK
        bigint bet_id FK
        varchar type
        decimal amount
        varchar status
        timestamp created_at
    }
```

## 4. Схема потока данных (Data Flow)

```mermaid
flowchart LR
    subgraph "External World"
        USER[User Browser]
    end

    subgraph "Frontend"
        UI[React UI]
        STORE[Zustand Store]
        HTTP[Axios HTTP Client]
    end

    subgraph "API Gateway"
        FILTER[Auth Filter]
        ROUTER[Router]
    end

    subgraph "Auth Domain"
        AUTH_CTRL[Auth Controller]
        AUTH_SVC[Auth Service]
        JWT_UTIL[JWT Utility]
    end

    subgraph "Core Domain"
        EVENT_CTRL[Event Controller]
        BET_CTRL[Bet Controller]
        BET_SVC[Bet Service]
        SETTLE_SVC[Settlement Service]
        EVENT_LISTENER[Kafka Listener]
    end

    subgraph "Realtime Domain"
        SCHEDULER[Data Scheduler]
        PARSER[Data Parser]
        KAFKA_PROD[Kafka Producer]
    end

    subgraph "Persistence"
        REPO[JPA Repositories]
        DB[(PostgreSQL)]
    end

    subgraph "Messaging"
        KAFKA_BROKER[Kafka Broker]
    end

    USER --> UI
    UI <--> STORE
    STORE --> HTTP
    HTTP --> FILTER
    FILTER --> ROUTER

    ROUTER --> AUTH_CTRL
    AUTH_CTRL --> AUTH_SVC
    AUTH_SVC --> JWT_UTIL
    AUTH_SVC --> REPO

    ROUTER --> EVENT_CTRL
    ROUTER --> BET_CTRL
    BET_CTRL --> BET_SVC
    EVENT_CTRL --> BET_SVC
    BET_SVC --> SETTLE_SVC
    BET_SVC --> REPO

    SCHEDULER --> PARSER
    PARSER --> KAFKA_PROD
    KAFKA_PROD --> KAFKA_BROKER
    KAFKA_BROKER --> EVENT_LISTENER
    EVENT_LISTENER --> REPO

    REPO --> DB

    style USER fill:#87CEEB
    style UI fill:#61dafb
    style FILTER fill:#ffeb3b
    style AUTH_SVC fill:#ff9900
    style BET_SVC fill:#ff6600
    style SETTLE_SVC fill:#e91e63
    style KAFKA_BROKER fill:#231f20
    style DB fill:#336791
```

## 5. Схема безопасности (Security Flow)

```mermaid
flowchart TD
    START([Client Request]) --> HAS_TOKEN{Has JWT<br/>Token?}

    HAS_TOKEN -->|No| PUBLIC{Public<br/>Endpoint?}
    PUBLIC -->|Yes| ALLOW[Allow Request]
    PUBLIC -->|No| REJECT401[Reject 401<br/>Unauthorized]

    HAS_TOKEN -->|Yes| VALIDATE[API Gateway<br/>Validates JWT]
    VALIDATE --> VALID{Token<br/>Valid?}

    VALID -->|No| REJECT401
    VALID -->|Yes| EXTRACT[Extract Email<br/>from Token]
    EXTRACT --> ADD_HEADER[Add Header:<br/>X-Authenticated-User-Email]
    ADD_HEADER --> ROUTE[Route to<br/>Microservice]
    ROUTE --> SERVICE[Service uses<br/>email for user context]
    SERVICE --> PROCESS[Process Request]
    PROCESS --> RESPONSE[Return Response]

    ALLOW --> RESPONSE
    REJECT401 --> END([End])
    RESPONSE --> END

    style START fill:#90EE90
    style REJECT401 fill:#FF6B6B
    style ALLOW fill:#90EE90
    style RESPONSE fill:#90EE90
    style VALIDATE fill:#FFD700
    style SERVICE fill:#87CEEB
```

## 6. Схема развертывания (Deployment)

```mermaid
graph TB
    subgraph "Docker Host"
        subgraph "boombet-network"
            GW_C[api-gateway<br/>Container<br/>Port 8080]
            AUTH_C[auth-service<br/>Container<br/>Port 8081]
            CORE_C[core-service<br/>Container<br/>Port 8082]
            RT_C[realtime-service<br/>Container<br/>Port 8083]
            PG_C[postgres<br/>Container<br/>Port 5432]
            ZK_C[zookeeper<br/>Container<br/>Port 2181]
            K_C[kafka<br/>Container<br/>Port 9092]
        end

        PG_VOL[postgres-data<br/>Volume]
    end

    subgraph "Host Machine"
        FE_DEV[Frontend Dev Server<br/>Vite :3000]
    end

    FE_DEV -->|http://localhost:8080| GW_C

    GW_C --> AUTH_C
    GW_C --> CORE_C
    GW_C --> RT_C

    AUTH_C --> PG_C
    CORE_C --> PG_C
    RT_C --> K_C
    K_C --> CORE_C
    K_C --> ZK_C

    PG_C -.->|Persist| PG_VOL

    style GW_C fill:#6db33f
    style AUTH_C fill:#ff9900
    style CORE_C fill:#ff6600
    style RT_C fill:#9933ff
    style PG_C fill:#336791
    style K_C fill:#231f20
    style ZK_C fill:#666
    style FE_DEV fill:#61dafb
    style PG_VOL fill:#ffd700
```

## 7. Схема жизненного цикла ставки

```mermaid
stateDiagram-v2
    [*] --> Placed: User places bet
    Placed --> Pending: Payment processed

    Pending --> Processing: Event finished

    Processing --> Won: All selections correct
    Processing --> Lost: Any selection incorrect
    Processing --> Cancelled: Event cancelled

    Won --> Settled: Payout credited
    Lost --> Settled: No payout
    Cancelled --> Refunded: Stake returned

    Settled --> [*]
    Refunded --> [*]

    note right of Placed
        - Validate selections
        - Check balance
        - Calculate odds
    end note

    note right of Pending
        - Stake deducted
        - Bet recorded
        - Transaction created
        - Waiting for event
    end note

    note right of Processing
        - Event result parsed
        - Outcomes determined
        - Scheduler checks (30s)
    end note

    note right of Won
        - Payout calculated
        - Balance credited
        - WIN transaction
    end note

    note right of Lost
        - No payout
        - Bet closed
    end note
```

## 8. Схема планировщиков (Schedulers)

```mermaid
gantt
    title Scheduled Tasks Timeline
    dateFormat ss
    axisFormat %S sec

    section Realtime Service
    Generate Mock Data (120s) :active, rt1, 00, 120s
    Publish to Kafka :milestone, rt2, 120, 0s
    Generate Mock Data :rt3, 120, 120s

    section Core Service
    Event Status Check (30s) :active, es1, 00, 30s
    Event Status Check :es2, 30, 30s
    Event Status Check :es3, 60, 30s
    Event Status Check :es4, 90, 30s

    section Core Service
    Bet Settlement (30s) :active, bs1, 00, 30s
    Bet Settlement :bs2, 30, 30s
    Bet Settlement :bs3, 60, 30s
    Bet Settlement :bs4, 90, 30s

    section Kafka Consumer
    Listen for events :active, kc1, 00, 120s
```

---

## Как использовать эти схемы:

### Для презентации:

1. **Общая схема (#1)** - показывает всю архитектуру на одном слайде
2. **Схема коммуникации (#2)** - объясняет пошаговое взаимодействие
3. **База данных (#3)** - показывает структуру данных

### Для объяснения:

- **Data Flow (#4)** - для вопросов "как данные проходят через систему"
- **Security Flow (#5)** - для вопросов о безопасности
- **Lifecycle (#7)** - для вопросов о бизнес-логике

### Для развертывания:

- **Deployment (#6)** - показывает Docker контейнеры
- **Schedulers (#8)** - объясняет фоновые задачи

---

## Экспорт схем:

Эти Mermaid схемы можно:

1. **Отрендерить в VS Code** с расширением Mermaid Preview
2. **Экспортировать в PNG/SVG** через [mermaid.live](https://mermaid.live)
3. **Вставить в презентацию** PowerPoint/Google Slides
4. **Показать в браузере** через GitHub/GitLab (рендерят Mermaid автоматически)
